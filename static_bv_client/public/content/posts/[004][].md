# Algorithms for free
## 

So far we define our image as

```cpp

using u8 = unsigned char;
using u32 = unsigned;


typedef struct pixel_t
{
    u8 red;
    u8 green;
    u8 blue;
    u8 alpha;
} Pixel;


typedef struct image_t
{
    u32 width;
    u32 height;

    Pixel* data;
} Image;
```

C++ algorithms https://en.cppreference.com/w/cpp/algorithm

```cpp
#include <vector>
#include <algorithm>


void vector_example(size_t size)
{
    std::vector<int> vec(size);
    
    std::iota(vec.begin(), vec.end(), 1); // { 1, 2, 3, 4, ... , size }
    // https://en.cppreference.com/w/cpp/algorithm/iota 

    auto const times_two = [](int& n){ n *= 2; };
    
    std::for_each(vec.begin(), vec.end(), times_two); // double each element
    // https://en.cppreference.com/w/cpp/algorithm/for_each

    std::vector<int> dst(size);

    std::transform(vec.begin(), vec.end(), dst.begin(), times_two);
    // https://en.cppreference.com/w/cpp/algorithm/transform
}

// std::execution::par


```


Here is a class used for timing things.  Copy and save it to a file called stopwatch.hpp

```cpp
#pragma once
#include <chrono>

class Stopwatch
{
private:
	std::chrono::system_clock::time_point start_;
	std::chrono::system_clock::time_point end_;
	bool is_on_ = false;

	std::chrono::system_clock::time_point now() { return std::chrono::system_clock::now(); }

public:
	Stopwatch()
	{
		start_ = now();
		end_ = start_;
	}

	void start()
	{
		start_ = now();
		is_on_ = true;
	}

	void stop()
	{
		end_ = now();
		is_on_ = false;
	}

	double get_time_milli()
	{
		std::chrono::duration<double, std::milli> delay = is_on_ ? now() - start_ : end_ - start_;

		return delay.count();
	}

	double get_time_sec()
	{
		std::chrono::duration<double> delay = is_on_ ? now() - start_ : end_ - start_;

		return delay.count();
	}

};
```