# Algorithms for free
## And parallelism too


### Standard Algorithms

There are a multitude of algorithms available in the C++ Standard Template Library (STL).  Cppreference is a good resource https://en.cppreference.com/w/cpp/algorithm.  There's no need to have them all memorized but it is good to know what is available.  There is a good chance that something already exists that will do what you need.  It can save you a lot of time trying to implement it yourself and also make your code cleaner and more readable.

The STL algorithms operate on a range of elements that you specify by providing an iterator to the first element and another to one past the last element.  The standard containers have methods for begin() and end() respectively.  Consider the following example.

```cpp
#include <vector>
#include <algorithm>
#include <numeric>
#include <random>


int do_work(int n)
{    
    // This post is not about random number generation.
    // We just want a function that takes some time to complete.
    std::random_device r;
    std::default_random_engine eng(r());
    std::uniform_int_distribution<int> uniform_dist(10, 1000);

    int sum = 0;

    for(int i = 0; i < 100; ++i)
    {
        sum += uniform_dist(eng) % 3;
    }

    return sum;
}


void algorithm_example(size_t size)
{
    std::vector<int> vec(size);
    
    // { 1, 2, 3, 4, ... , size }
    std::iota(vec.begin(), vec.end(), 1);

    auto const times_two = [](int& n){ n *= 2; };
    
    // double each element
    std::for_each(vec.begin(), vec.end(), times_two);

    std::vector<int> dst(size);

    // apply the do_work function to each value and store the results in dst
    std::transform(vec.begin(), vec.end(), dst.begin(), do_work);
}
```

The do_work function is intended to take some time generating a result.  It accumulates the a modulus calculation of 100 randomly generated numbers.

The algorithm_example function demonstrates the standard algorithms std::iota, std::for_each and std::transform.  It does the following.
* Create a vector with the specified number of elements
* Fill the vector with sequencially increasing numbers starting at 1 (https://en.cppreference.com/w/cpp/algorithm/iota)
* Apply a lambda to each element, doubling them (https://en.cppreference.com/w/cpp/algorithm/for_each)
* Create another vector with the same size as the first.
* Call the do_work function with each element and save the result in the new vector (https://en.cppreference.com/w/cpp/algorithm/transform)

These algorithms operate on each element one at a time starting at the beginning and moving sequencially until it reaches the end or the end iterator you provide.  For example, you can sort only the first 10 elements of a containiner.

```cpp
std::sort(vec.begin(), vec.begin() + 10);
```

### Parallelism

If your collections are quite large, then operating on each element one at a time can be a bottleneck in your application.  C++17 introduced the ability for many algorithms to use multi-threading in order to process several elements at the same time.  How this is executed will depend on the operating system and the computer's CPU.  What this means for developers is that this functionality is available without any extra programming.  We only need to pass a parameter indicating that we wish the algorithm to execute in parallel.

```cpp
#include <execution>


void algorithm_example_par(size_t size)
{
    std::vector<int> vec(size);
    
    // { 1, 2, 3, 4, ... , size }
    std::iota(vec.begin(), vec.end(), 1);

    auto const times_two = [](int& n){ n *= 2; };
    
    // double each element
    std::for_each(std::execution::par, vec.begin(), vec.end(), times_two);

    std::vector<int> dst(size);

    // apply the do_work function to each value and store the results in dst
    std::transform(std::execution::par, vec.begin(), vec.end(), dst.begin(), do_work);
}
```

This example is the same as the one above except that we passed the Execution Policy std::execution::par to std::for_each and std::transform.  This should take less time to execute but we need to test it manually.


### Example

The following class can be used for timing processes.  Copy and save it to a file called stopwatch.hpp

```cpp
#pragma once
#include <chrono>

class Stopwatch
{
private:
	std::chrono::system_clock::time_point start_;
	std::chrono::system_clock::time_point end_;
	bool is_on_ = false;

	std::chrono::system_clock::time_point now() { return std::chrono::system_clock::now(); }

public:
	Stopwatch()
	{
		start_ = now();
		end_ = start_;
	}

	void start()
	{
		start_ = now();
		is_on_ = true;
	}

	void stop()
	{
		end_ = now();
		is_on_ = false;
	}

	double get_time_milli()
	{
		std::chrono::duration<double, std::milli> delay = is_on_ ? now() - start_ : end_ - start_;

		return delay.count();
	}

	double get_time_sec()
	{
		std::chrono::duration<double> delay = is_on_ ? now() - start_ : end_ - start_;

		return delay.count();
	}

};
```

This program runs each example and outputs their execution times.

```cpp
#include <iostream>

#include "stopwatch.hpp"


int main()
{
    Stopwatch sw;

    auto const print_time = [&](const char* msg) { std::cout << msg << ": " << sw.get_time_milli() << "ms\n"; };

    size_t count = 100000;

    std::cout<<'\n';

    sw.start();

    algorithm_example(count);
    print_time("sequential");

    sw.start();
    algorithm_example_par(count);
    print_time("  parallel");
}

```

Output when running in debug mode.

![alt text](https://github.com/adam-lafontaine/CMS/raw/master/img/%5B004%5D/debug.png)

Output when running in release mode.

![alt text](https://github.com/adam-lafontaine/CMS/raw/master/img/%5B004%5D/release.png)